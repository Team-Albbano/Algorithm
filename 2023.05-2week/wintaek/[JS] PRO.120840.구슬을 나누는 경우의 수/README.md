<!-- 제목으로 다음과 같은 내용으로 작성해주세요 ! -->
<!-- 📚 언어 : e.g. Javascript -> [JS], Python -> [Python]  -->
<!-- 📕 백준 : BOJ 문제번호/문제제목 e.g. BOJ 2577/숫자의 개수 -->
<!-- 📗 프로그래머스 : PRO 문제번호/문제제목 e.g. PRO 120812/최빈값 구하기 -->
<!-- 💁🏻 백준허브를 사용하시면 프로그래머스의 문제번호도 확인하실 수 있습니다 -->

# [JS] PRO.120840.구슬을 나누는 경우의 수

<!-- 아래에 # 을 지우고 문제 링크를 입력해주세요 ! -->

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/120840)

## Table of Contents

- [✍🏻 풀이](#풀이)
- [⏰ 소요시간](#소요시간)
- [🫠 어려웠던 점](#어려웠던-점)
- [😮 배운 점](#배운-점)
- [🤔 궁금한 점](#궁금한-점)

## 풀이

<!-- ```옆에 사용하는 언어를 기입하세요 e.g. javascript, python -->

풀이 설명란

- hint 에 작성되어있는 팩토리얼을 보고 [재귀와 스택] (https://ko.javascript.info/recursion#ref-80)을 참고하였습니다.
- ` n!`은 `n * (n-1)!`입니다. num이 1이 될 때까지 계속 반복해줍니다
- 서로 다른 n개 중 m개를 뽑는 경우의 수 공식에 팩토리얼을 집어넣어 식을 완성시켰습니다.

```javascript
const 팩토리얼 = (num) => (num === 0 ? 1 : num * 팩토리얼(num - 1));

function solution(balls, share) {
  return Math.round(
    팩토리얼(balls) / 팩토리얼(balls - share) / 팩토리얼(share)
  );
}
```

## 소요시간

50분

## 어려웠던 점

## 배운 점

처음에 Math.round 를 왜 써야 통과가 될 까 싶었는데, 우리는 보통 계산을 할 때 10진법을 사용하지만 컴퓨터는 0과 1만 사용하는 2진법을 사용한다. 때문에 소숫점에서 우리가 생각한 예상과는 반대로 유한소숫점을 뱉어버리기 때문에 Math.round를 이용함으로써 소숫점을 반올림 처리 후 정수값을 뱉게 한다는 점을 배웠습니다.

## 궁금한 점
